Міністерство освіти і науки України
Національний технічний університет України «Київський політехнічний
інститут імені Ігоря Сікорського»
Факультет інформатики та обчислювальної техніки

Кафедра інформатики та програмної інженерії


Звіт

з лабораторної роботи № 5
з дисципліни
«Алгоритми та структури даних. Частина 2. Структури даних»

«Метод швидкого сортування»





 
Виконав(ла) 


Перевірив


ІП-33 Цапурда Є. Д.
(шифр, прізвище, ім'я, по батькові)
	
Соколовський В. В
(прізвище, ім'я, по батькові)

 



Київ 2024
Постановка задачі:
Розробити алгоритм розв’язання задачі відповідно до варіанту. Виконати програмну реалізацію задачі. Не використовувати вбудовані деревовидні структури даних (контейнери). Зробити висновок по лабораторній роботі.
29.  Побудувати двійкове дерево пошуку, в вершинах якого знаходяться цілі числа. Визначити максимальну висоту дерева, тобто число ребер в найдовшому шляху від кореня до листків.
Псевдокод алгоритму:
1. class Node:
2.     Node Right
3.     Node Left
4.     Integer Data
5.     
6.     Constructor Node(item):
7.         Set Data ← item
8.         Set Right ← null
9.         Set Left ← null
10. 
11. class BinaryTree:
12.     Node root
13.     
14.     Private method Insert(node, data):
15.         do if node = null
16.             then Return new Node(data)
17.         
18.         do if data < node.Data
19.             then Set node.Left ← Insert(node.Left, data)
20.         else if data > node.Data
21.             then Set node.Right ← Insert(node.Right, data)
22.         
23.         Return node
24.     
25.     Public method Insert(data):
26.         Set root ← Insert(root, data)
27.     
28.     Private method Height(node):
29.         do if node = null
30.             then Return 0
31.         
32.         Set leftHeight ← Height(node.Left)
33.         Set rightHeight ← Height(node.Right)
34.         
35.         Return Max(leftHeight, rightHeight) + 1
36.     
37.     Public method Height():
38.         Return Height(root)

Код програми (C#): 

Console.WriteLine("Введіть через пробіл числа для побудови бінарного деревера пошуку:");
string[] numbers = Console.ReadLine().Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

BinaryTree tree = new BinaryTree();

foreach (var number in numbers)
{
    tree.Insert(Int32.Parse(number));
}

Console.WriteLine($"Висота побудованого дерева: {tree.Height()}");

class Node
{
    public Node Right;
    public Node Left;
    public int Data;

    public Node(int item)
    {
        Data = item;
        Right = Left = null;
    }
}

class BinaryTree
{
    public Node root;

    private Node Insert(Node node, int data)
    {
        if (node == null)
            return new Node(data);

        if (data < node.Data)
            node.Left = Insert(node.Left, data);
        else if (data > node.Data)
            node.Right = Insert(node.Right, data);

        return node;
    }

    public void Insert(int data)
    {
        root = Insert(root, data);
    }

    private int Height(Node node)
    {
        if (node == null)
            return 0;

        int leftHeight = Height(node.Left);
        int rightHeight = Height(node.Right);

        return Math.Max(leftHeight, rightHeight) + 1;
    }

    public int Height()
    {
        return Height(root) - 1;
    }
}

Робота програми:
Консоль програми:
 
Рис. 1. Консоль після запуску програми
 
Рис. 2. Вводимо числа для побудови дерева та отримуємо результат
 
Рис. 3. Бінарне дерево


Розрахунок складності та аналіз алгоритму:
Двійкове дерево пошуку (Binary Search Tree, BST) - це структура даних, яка використовується в комп'ютерних науках для ефективного зберігання та пошуку впорядкованих даних. Кожен вузол двійкового дерева пошуку містить значення (яке називається ключем) і дві посилання на інші вузли: лівого нащадка і правого нащадка. Вузли впорядковані таким чином, що для кожного вузла X всі вузли в лівому піддереві мають значення ключів менше, ніж значення ключа вузла X, а всі вузли в правому піддереві мають значення ключів більше, ніж значення ключа вузла X.
Основною перевагою двійкового дерева пошуку перед іншими структурами даних є можлива висока ефективність реалізації заснованих на ньому алгоритмів пошуку та сортування . Бінарні дерева пошуку набагато ефективніші в операціях пошуку, аніж лінійні структури, в яких витрати часу на пошук пропорційні θ(n), де n — розмір масиву даних, тоді як в повному бінарному дереві цей час пропорційний в середньому θ(log_2⁡〖n)〗 або θ(h), де h — висота дерева. Проте гарантувати, що h не перевищує log_2⁡n можна лише для збалансованих дерев, які є ефективнішими в алгоритмах пошуку. Тобто, якщо дерево незбалансоване (наприклад, якщо вузли додаються в відсортованому порядку), його висота може бути лінійною, і операції будуть займати більше часу.

	В середньому випадку	В гіршому випадку
Витрати пам’яті	θ(n)	θ(n)
Пошук	θ(log_2⁡〖n)〗	θ(n)
Вставка	θ(log_2⁡〖n)〗	θ(n)
Вилучення	θ(log_2⁡〖n)〗	θ(n)






Висновок:
Під час виконання цієї лабораторної роботи ми розробили алгоритм для побудови двійкового дерева пошуку, в якому в вершинах знаходяться цілі числа, та визначили максимальну висоту цього дерева, що відповідає кількості ребер у найдовшому шляху від кореня до листків.

Основні кроки алгоритму включають вставку елементів у дерево, визначення висоти дерева та пошук максимальної висоти шляху від кореня до листків. Під час вставки кожен новий елемент порівнюється з елементами у вузлах дерева і вставляється відповідно до порядку зростання. Для побудови дерева використовується рекурсивний підхід.

Ми успішно реалізували цей алгоритм у програмному коді без використання вбудованих деревоподібних структур даних. Після цього ми визначили максимальну висоту дерева, що є важливим показником ефективності його операцій. Ми також оцінили часову складність розробленого алгоритму. Вставка елемента у двійкове дерево пошуку зазвичай має часову складність θ(log⁡n), де n - кількість елементів у дереві. Однак, у випадку незбалансованого дерева, наприклад, коли елементи вставляються в порядку зростання або спадання, часова складність може сягати θ(n), де n - кількість елементів, що може призвести до значного збільшення часу виконання операцій.

Підсумовуючи, лабораторна робота дозволила нам отримати практичний досвід роботи з двійковими деревами пошуку та їх реалізацією в програмному коді. Ми розуміємо основні принципи їх функціонування та важливість оптимізації для забезпечення швидкої роботи дерева навіть при великій кількості вузлів.
![image](https://github.com/R0BIK/HeightOfBST/assets/99051328/3d1258d1-b1d5-41b9-90e7-e3c518c8d6b6)
